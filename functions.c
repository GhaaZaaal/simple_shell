#include "main.h"

/**
 * display_prompt - function to display the prompt message
 */
void display_prompt(void)
{
	char *prompt = "$ ";

	if (write(STDOUT_FILENO, prompt, 2) == -1)
		perror("Prompt Error");

	fflush(stdout);
}
/**
 * get_line - Function to get a line from the user
 *
 * @cmd_line: buffer to store the line in
 * @cmd_len: the length of the line (modifiable)
 * @paths: the path to check
 * @exit_code: the exit code of the last command if C+D is pressed
 *
 * Return: -1 if C+D pressed or 0 on success with reading
 */
void get_line(char **cmd_line, size_t cmd_len, char *paths[], int exit_code)
{
	size_t linelen;

	*cmd_line = (char *)malloc((cmd_len + 1) * sizeof(char));
	linelen = getline(cmd_line, &cmd_len, stdin);
	if ((int)linelen == -1)
	{ /* if user press CTRL + D => getline outputs (-1) */
		/* putchar('\n'); */
		free(*cmd_line);
		if (paths != NULL)
			free_array(paths);
		exit(exit_code);
	}
	else if (linelen == 1)
	{
		**cmd_line = '\0';
	}
	else if ((*cmd_line)[linelen - 1] == '\n')
	{ /* if user inputs any even if (\n) (! condition to input any) */
		(*cmd_line)[linelen - 1] = '\0';
		if (check_if_spaces(*cmd_line) == -1)
			**cmd_line = '\0';
	}
}
/**
 * compare_with_path - it compares path to execute
 * @_1_tok: tokenized cmd
 * @path_array: path need to be compared
 *
 * Return: full path to execute
 */
char *compare_with_path(char *_1_tok, char *path_array[])
{
	int i, paLen = 0, cmLen = 0, tmpLen = 0;
	char *full_path = NULL;
	char *tmp = "/";

	if (_1_tok[0] == '/')
	{
		full_path = _strcopy(_1_tok);
		if (access(full_path, X_OK) == 0)
		{						/* printf("3aaash ====> %s\n", full_path); */
			return (full_path); /* need to be freed */
		}
		/* printf("full_path: %s\n", full_path); */
		free(full_path);
	}
	else if (path_array != NULL)
	{
		for (i = 0; path_array[i] != NULL; i++)
		{
			paLen = _strlen(path_array[i]);
			cmLen = _strlen(_1_tok), tmpLen = _strlen(tmp);
			full_path = (char *)malloc((paLen + cmLen + tmpLen + 1) * sizeof(char));
			/* keep malloced if access success */
			if (full_path == NULL)
			{
				perror("malloc full_path");
				exit(3);
			}
			_strcpy(full_path, path_array[i]);
			if (full_path[paLen - 2] != '/')
				_strcat(full_path, tmp);
			_strcat(full_path, _1_tok);
			if (access(full_path, X_OK) == 0)
			{						/* printf("3aaash ====> %s\n", full_path); */
				return (full_path); /* need to be freed */
			}
			/* printf("full_path: %s\n", full_path); */
			free(full_path);
		}
	}
	return (NULL);
}
/**
 * _execute_some - Function that executes the command given by the user
 *
 * @pathname: the path name of the command generated by another function
 * @cmd_line: the string containing the command to be toknized
 * @tok_count: the number of tokens in the command string
 * @envp: the path toknied in array of strings to search in for the command
 *
 * Return: Always 0 on (success), 1 on (failure)
 */
int _execute_some(char *pathname, char *cmd_line, int tok_count, char *envp[])
{
	char **av = NULL;
	char *tokstr = NULL;
	int i = 0, id, status = 0;

	av = (char **)malloc((tok_count + 1) * sizeof(char *));
	if (av == NULL)
	{
		perror("malloc av");
		exit(5);
	}

	tokstr = strtok(cmd_line, " ");
	while (tokstr != NULL)
	{
		av[i] = tokstr;
		tokstr = strtok(NULL, " ");
		i++;
	}
	av[i] = NULL;
	id = fork();
	if (id == 0)
	{
		if (execve(pathname, av, envp) == -1)
		{
			perror("Error");
		}
	}
	else
	{
		waitpid(id, &status, 0);
		free(av);
		return (WEXITSTATUS(status));
	}
	return (0);
}
/**
 * _input - Function that gets a line from the user
 *				and parses the user input
 *
 * @cM: the string to store the input command line
 * @cL: the size recommended to allocate that string with
 * @pt: the array of paths strings
 * @cct: number of tokens
 * @av: the arguments passed while running the program
 * @ev: environment variables
 */
void _input(char **cM, size_t cL, char *pt[], int cct, char *av[], char *ev[])
{
	char *cmd_copy = NULL, *cpy_tok = NULL, *tok_mch = NULL;
	int counter = 1;
	static int exit_code;

	get_line(cM, cL, pt, exit_code);
	if (**cM == '\0')
	{
		free(*cM);
		return;
	}
	cmd_copy = _strcopy(*cM);
	cpy_tok = _strcopy(strtok(cmd_copy, " "));
	while (strtok(NULL, " ") != NULL)
		counter++;
	free(cmd_copy);
	if (strncmp(cpy_tok, "exit", 4) == 0)
	{
		free(cpy_tok), free_array(pt);
		execExit(cM, counter, cct, exit_code, av[0]);
	}
	if (strncmp(cpy_tok, "cd", 2) == 0)
	{
		execCd(*cM, ev);
		free(cpy_tok), free(*cM);
		return;
	}
	tok_mch = compare_with_path(cpy_tok, pt);
	if (tok_mch != NULL)
		exit_code = _execute_some(tok_mch, *cM, counter, ev);
	else
	{
		fprintf(stderr, "%s: %d: %s: not found\n", av[0], cct, cpy_tok);
		fflush(stdout);
		exit_code = 127;
	}
	free(cpy_tok), free(*cM), free(tok_mch);
}
