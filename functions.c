#include "main.h"

/**
 * display_prompt - function to display the prompt message
 */
void display_prompt(void)
{
	/* char *wd = getcwd(NULL, 0); */
	/* int wd_len = _strlen(wd); */
	char *prompt = "$ ";

	/* if (write(STDOUT_FILENO, wd, wd_len) == -1) */
	/* perror("Working Dir Error"); */
	if (write(STDOUT_FILENO, prompt, 2) == -1)
		perror("Prompt Error");

	fflush(stdout);
}
/**
 * get_line - Function to get a line from the user
 *
 * @cmd_line: buffer to store the line in
 * @cmd_len: the length of the line (modifiable)
 * @paths: the path to check
 *
 * Return: -1 if C+D pressed or 0 on success with reading
 */
void get_line(char **cmd_line, size_t cmd_len, char *paths[])
{
	size_t linelen;

	*cmd_line = (char *)malloc((cmd_len + 1) * sizeof(char));
	linelen = getline(cmd_line, &cmd_len, stdin);
	if ((int)linelen == -1)
	{ /* if user press CTRL + D => getline outputs (-1) */
		putchar('\n');
		free(*cmd_line);
		free_array(paths);
		exit(0);
	}
	else if (linelen == 1)
	{
		**cmd_line = '\0';
	}
	else if ((*cmd_line)[linelen - 1] == '\n')
	{ /* if user inputs any even if (\n) (! condition to input any) */
		(*cmd_line)[linelen - 1] = '\0';
	}
}
/**
 * compare_with_path - it compares path to execute
 * @_1_tok: tokenized cmd
 * @path_array: path need to be compared
 *
 * Return: full path to execute
 */
char *compare_with_path(char *_1_tok, char *path_array[])
{
	int i, paLen = 0, cmLen = 0, tmpLen = 0;
	char *full_path = NULL;
	char *tmp = "/";

	for (i = 0; path_array[i] != NULL; i++)
	{
		paLen = _strlen(path_array[i]);
		cmLen = _strlen(_1_tok);
		tmpLen = _strlen(tmp);
		if (_1_tok[0] == '/')
			full_path = _strcopy(_1_tok);

		else
		{
			full_path = (char *)malloc((paLen + cmLen + tmpLen + 1) * sizeof(char));
			/* keep malloced if access success */
			if (full_path == NULL)
			{
				perror("malloc full_path");
				exit(3);
			}
			_strcpy(full_path, path_array[i]);
			if (full_path[paLen - 2] != '/')
				_strcat(full_path, tmp);

			_strcat(full_path, _1_tok);
		}
		if (access(full_path, X_OK) == 0)
		{
			/* printf("3aaash ====> %s\n", full_path); */
			return (full_path); /* need to be freed */
		}
		/* printf("full_path: %s\n", full_path); */
		free(full_path);
	}

	return (NULL);
}
/**
 * _execute_some - Function that executes the command given by the user
 *
 * @pathname: the path name of the command generated by another function
 * @cmd_line: the string containing the command to be toknized
 * @tok_count: the number of tokens in the command string
 * @envp: the path toknied in array of strings to search in for the command
 *
 * Return: Always 0 on (success), 1 on (failure)
 */
int _execute_some(char *pathname, char *cmd_line, int tok_count, char *envp[])
{
	char **av = NULL;
	char *tokstr = NULL;
	int i = 0, id;

	av = (char **)malloc((tok_count + 1) * sizeof(char *));
	if (av == NULL)
	{
		perror("malloc av");
		exit(5);
	}

	tokstr = strtok(cmd_line, " ");
	while (tokstr != NULL)
	{
		av[i] = tokstr;
		tokstr = strtok(NULL, " ");
		i++;
	}
	av[i] = NULL;
	id = fork();
	if (id == 0)
	{
		if (execve(pathname, av, envp) == -1)
		{
			perror("Error");
		}
	}
	else
	{
		wait(NULL);
		free(av);
		return (1);
	}
	return (0);
}
/**
 * user_input - Function that gets a line from the user
 *				and parses the user input
 *
 * @c_l: the string to store the input command line
 * @clen: the size recommended to allocate that string with
 * @paths: the array of paths strings
 * @cct: number of tokens
 */
void user_input(char **c_l, size_t clen, char *paths[], int cct)
{
	char *cmd_copy = NULL, *cpy_tok = NULL, *tok_mch = NULL;
	int counter = 1;

	get_line(c_l, clen, paths);
	if (**c_l == '\0')
	{
		free(*c_l);
		return;
	}
	cmd_copy = _strcopy(*c_l);

	cpy_tok = _strcopy(strtok(cmd_copy, " "));
	while (strtok(NULL, " ") != NULL)
		counter++;
	free(cmd_copy);
	if (strncmp(cpy_tok, "exit", 4) == 0)
	{
		free(cpy_tok);
		free_array(paths);
		execExit(c_l, counter);
		return;
	}
	tok_mch = compare_with_path(cpy_tok, paths);
	if (tok_mch != NULL)
		_execute_some(tok_mch, *c_l, counter, paths);
	else
	{
		printf("hsh: %d: %s: not found\n", cct, cpy_tok);
		fflush(stdout);
	}
	free(cpy_tok), free(*c_l), free(tok_mch);
}
